<!doctype html>
<html>
  <body>
    <!-- fixed-size canvas so we don't worry about resizing -->
    <canvas id="plot" width="800" height="400" style="border:1px solid #ccc"></canvas>

    <script>
      //:LiveServerStart

      const surfaceN = 7;
      const landOrigX = [0, 1000, 1500, 3000, 4000, 5500, 6999];
      const landOrigY = [100, 500, 1500, 1000, 150, 150, 800];

      console.error(landOrigX);
      console.error(landOrigY);

      // at least 1000m wide
      let firstFlatIdx = 0;
      let secondFlatIdx = 0;
      for (let i = 1; i < surfaceN; i++) {
          if (landOrigY[i] === landOrigY[i - 1]) {
              firstFlatIdx = i - 1;
              secondFlatIdx = i;
              break;
          }
      };

      const squareSize = 500;
      const leewayDist = 150;
      const landX = [];
      const landY = [];

      // These are a segment of the y-axis, they are used to prime the formula below.
      let x1 = 0;
      let x2 = 0;
      let y1 = 0;
      let y2 = 2999;

      function intersect(x3, x4, y3, y4) {
          // intersection formula
          const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
          const newX = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4))/d;
          const newY = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4))/d;

          return [newX, newY];
      }

      for (let i = 1; i < surfaceN; i++) {

          let x3 = -1;
          let x4 = -1;
          let y3 = -1;
          let y4 = -1;

          if (i === secondFlatIdx) {
              x3 = landOrigX[i - 1];
              x4 = landOrigX[i];
              y3 = landOrigY[i - 1];
              y4 = landOrigY[i];
          } else {
              const dY = landOrigY[i] - landOrigY[i-1];
              const dX = landOrigX[i] - landOrigX[i-1];

              const len = Math.hypot(dX, dY);

              if (!len) continue;

              // n = (-Δy, Δx)/sqrt((Δx)^2 + (Δy)^2)
              // A' = A + h*n
              // B' = B + h*n
              const normX = leewayDist * (-dY / len);
              const normY = leewayDist * (dX / len);
              
              x3 = landOrigX[i-1] + normX;
              x4 = landOrigX[i] + normX;
              y3 = landOrigY[i-1] + normY;
              y4 = landOrigY[i] + normY;
          }

          const [newX, newY] = intersect(x3, x4, y3, y4);

          landX.push(newX);
          landY.push(newY);

          x1 = x3;
          x2 = x4;
          y1 = y3;
          y2 = y4;
      };

      const [newX, newY] = intersect(6999, 6999, 0, 2999);

      landX.push(newX);
      landY.push(newY);

      let firstPass = true;

      function gridToStandardX(coord) {
          let conversion = coord * squareSize;
          if(conversion > 6999) {
              conversion = 6999;
          }
          return conversion;
      }

      function gridToStandardY(coord) {
          let conversion = coord * squareSize;
          if(conversion > 2999) {
              conversion = 2999;
          }
          return conversion;
      }

      function standardToGrid(coord) {
          return coord/squareSize;
      }

      function standardToGridCeil(coord) {
          return Math.ceil(coord/squareSize);
      }

      function standardToGridFloor(coord) {
          return Math.floor(coord/squareSize);
      }

      function segmentsIntersect(A, B, C, D, eps = 1e-10) {
          const cross = (p, q, r) => 
              (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);

          const orient = (p, q, r) => {
              const val = cross(p, q, r);
              if (Math.abs(val) < eps) return 0; // collinear
              return val > 0 ? 1 : -1;
          }

          const o1 = orient(A, B, C);
          const o2 = orient(A, B, D);
          const o3 = orient(C, D, A);
          const o4 = orient(C, D, B);

          // General case: proper intersection
          if (o1 !== o2 && o3 !== o4) return true;

          // Collinear special cases
          const onSeg = (p, q, r) =>
              Math.min(p.x, r.x) - eps <= q.x && q.x <= Math.max(p.x, r.x) + eps &&
              Math.min(p.y, r.y) - eps <= q.y && q.y <= Math.max(p.y, r.y) + eps;

          if (o1 === 0 && onSeg(A, C, B)) return true;
          if (o2 === 0 && onSeg(A, D, B)) return true;
          if (o3 === 0 && onSeg(C, A, D)) return true;
          if (o4 === 0 && onSeg(C, B, D)) return true;

          return false;
      }

      const x = 2500;
      const y = 2700;
      const hSpeed = 0;
      const vSpeed = 0;
      const fuel = 550;
      const rotate = 0;
      const power = 0;

      // Write an action using console.log()
      // To debug: console.error('Debug messages...');

      // Probably get above the landing area as fast as possible? This could be false later and I would
      // like to make it extendable. So maybe I need to actually find the shortest path to the surface, then
      // try to follow it closely. Although I would need to simulate that while the moves are all predictable
      // it can't follow tight paths. Maybe instead of thinking of it like a programming problem, think of it
      // like a real problem. That means I want it to work first and foremost, then I want to prio fuel, then
      // I want to prio computational efficieny.

      // Maybe break it up into a grid and do flow control over it? Then go over the path and see if it is valid & adjust
      // accordingly. OR I could figure out how tight the lander can corner and use flow control to somehow make the 
      // correct path the first time by being farther away from the edges.

      const distance = (x1, y1, x2, y2) => Math.hypot((x1 - x2), (y1 - y2));

      // TODO: Probably need to move all land except the landing pad "up". Probably do this above by modifying the coords.

      console.error(`lander [${x}, ${y}]`);
      let grid = [];

      if (firstPass) {
          const numRows = 3000/squareSize + 1;
          const numCols = 7000/squareSize + 1; 

          const isInGridBounds = (y, x) => y >= 0 && y < numRows && x >= 0 && x < numCols;

          // How does this work?
          // Start at the current coords. Every direction works, but I want the shortest path. So 
          // some kind of backtracking algo I suppose? Maybe start at the points on the grid that 
          // are "solutions" and then use backwards induction to find the shortest path.

          // Multiple possible end points. Pick one and start there.

          // Check each direction and keep track of length. Find shortest direction once I find
          // the lander.

          // Need coords of the current lander and the coords of the end points. Maybe I will need
          // to do some extra at the start and end to go to a corner. So from startX and startY to
          // the nearest coord and such. Oh, I can just add the distance to the nearest coordinates.

          // The actual coordinate that represents each square is the bottom left.
          // This allows it to be floor(X) and floor(Y) which makes computation 
          // simpler.
          for(let i = 0; i < numRows; i++) {
              let row = [];
              for (let j = 0; j < numCols; j++) {
                  row.push(-1);
              }
              grid.push(row);
          }

          // Mark coords directly above the ground coords.
          const gridLandingPoints = [];

          const flatY = landY[firstFlatIdx];
          const gridFlatY = standardToGridCeil(flatY);
          const convertFlatY = gridToStandardY(gridFlatY);

          const distanceToSquare = distance(0, flatY, 0, convertFlatY);

          const firstFlatX = landX[firstFlatIdx];
          const firstGridFlatX = standardToGridCeil(firstFlatX);

          const secondFlatX = landX[secondFlatIdx];
          const secondGridFlatX = standardToGridFloor(secondFlatX);
          const convertSecondGridFlatX = gridToStandardX(secondGridFlatX);

          for(let gridFlatX = firstGridFlatX; gridFlatX <= secondGridFlatX; gridFlatX++) {
            grid[gridFlatY][gridFlatX] = distanceToSquare;
            gridLandingPoints.push([gridFlatY, gridFlatX]);
          }

          const orthogDistance = distance(0, 0, squareSize, 0);
          const diagonalDistance = distance(0, 0, squareSize, squareSize);
          const DIRS = [
              [-1, -1, diagonalDistance],
              [-1, 0, orthogDistance],
              [-1, 1, diagonalDistance],
              [0, -1, orthogDistance],
              [0, 1, orthogDistance],
              [1, -1, diagonalDistance],
              [1, 0, orthogDistance],
              [1, -1, diagonalDistance]
          ];

          // Calculate and save the shortest distance from each grid point to the end point. It will
          // not calculate any point that fall outside the grid and will not move through any land.

          let headIdx = 0;
          const nextPoints = [...gridLandingPoints];
          while (headIdx < nextPoints.length) {
              const [gridY, gridX] = nextPoints[headIdx];
              const gridDist = grid[gridY][gridX];
              const workingY = gridToStandardY(gridY);
              const workingX = gridToStandardX(gridX);
              for (const [dy, dx, dist] of DIRS) {
                  const newGridY = gridY + dy;
                  const newGridX = gridX + dx;

                  if (isInGridBounds(newGridY, newGridX)) {
                      const newY = gridToStandardY(newGridY);
                      const newX = gridToStandardX(newGridX);

                      let outOfBounds = false;
                      for (let i = 1; i < surfaceN; i++) {

                          if (segmentsIntersect(
                                  {x: workingX, y: workingY},
                                  {x: newX, y: newY},
                                  {x: landX[i-1], y: landY[i-1]},
                                  {x: landX[i], y: landY[i]}
                          )) {
                              outOfBounds = true;
                              break;
                          }
                      }

                      const calculatedNextDist = gridDist + dist;
                      const actualNextDist = grid[newGridY][newGridX]; 
                      if (!outOfBounds && (actualNextDist === -1 || calculatedNextDist < actualNextDist)) {
                          grid[newGridY][newGridX] = calculatedNextDist;
                          nextPoints.push([newGridY, newGridX]);
                      }
                  }
              }
              headIdx++;
          }

          const gridStartingPoints = [];

          // These points can be duplicates, so doing it this way to avoid
          // the same point being used multiple times.
          const gridLanderXCoords = new Set();
          const gridLanderYCoords = new Set();
          gridLanderXCoords.add(standardToGridFloor(x));
          gridLanderXCoords.add(standardToGridCeil(x));
          gridLanderYCoords.add(standardToGridFloor(y));
          gridLanderYCoords.add(standardToGridCeil(y));

          for (const gridX of gridLanderXCoords) {
              for (const gridY of gridLanderYCoords) {
                  // Convert grid coords back to actual coords.
                  const landerX = gridToStandardX(gridX);
                  const landerY = gridToStandardY(gridY);

                  gridStartingPoints.push([gridY, gridX]);

                  // If this point could not be reached by the above algo, there is no
                  // path to reach the landing pad.
                  if (grid[gridY][gridX] !== -1) {
                      grid[gridY][gridX] += distance(x, y, landerX, landerY);
                  }
              }
          }

          let smallest = -1;
          let pathX = -1;
          let pathY = -1;

          //find the shorest path around the lander
          for (const [startX, startY] of gridStartingPoints) {
              if (smallest === -1 || grid[startY][startX] < smallest) {
                  pathX = startX;
                  pathY = startY;
                  smallest = grid[startY][startX];
              }
          }

          const path = [[pathX, pathY]];
          const pathFound = false;

          //TODO: Something is wrong with the starting point. It isn't correct. It also
          // goes up and out of bounds instead of in the correct direction.
          //TODO: might work better if grid has wether it is a landing point stored inside it.
          // while(!pathFound) {
          for (let i = 0; i < 3; i++) {
              //gridLandingPoints
              const [curX, curY] = path[path.length-1];
              smallest = -1;
              for (const [dy, dx, _] of DIRS) {
                  const newX = curX + dx;
                  const newY = curY + dy;
                  if (isInGridBounds(newY, newX) && grid[newY][newX] !== -1
                      && (smallest === -1 || grid[newY][newX] < smallest)
                  ) {
                      pathX = newX;
                      pathY = newY;
                  }
              }
              path.push([pathX, pathY]);
              
              for(const [landY, landX] in gridLandingPoints) {
                  if (landX === pathX && landY === pathY) {
                      pathFound = true;
                      break;
                  }
              }
          }
          
          console.error(path);

          //TODO: Need to draw a line from the ship to the landing pad.
          // start at the ship points, find the smalles number, search each point afterwards
          // them in all six directions and take the smallest number
          //TODO: Need to smooth the line (cubic Hermite spline?)
          //TODO: Maybe do corners based on turn radius of lander.
          //TODO: Need to follow the line algorithmically.
          //TODO: How do I guarantee that the hv, vv, rot, etc.. are in bounds? Maybe I do
          // need more of a simulation for it. Or is there some way to reverse it so that I 
          // can find the min point that I need to start slowing/rotating.
          // For example, to slow vertical speed, I need to use the thrusters to go up. But
          // they don't need to be pointed straight down. I COULD just make the very end
          // fairly straight. However, this isn't a great solution. I think I should get the
          // initial part working first. Look ahead maybe.

          //TODO: Is there a better way to do this than finding shortest distance?
          //TODO: Maybe I just use the shortest path on the first time I go through it. Then every second after that
          // I recalculate it somehow and clean up the path based on new information. This is also a lot more practical
          // for a real world situation than trying to theoretically figure it out to start.
          //TODO: Last time I think I got stuck on the part of following the line with the shuttle well enough. Can I go
          // backwards and do it better somehow? How do I follow the line though? Or Do I need to remake the line based
          // on following it? I don't know if forwards or backwards matters. Maybe I just need to remake the line on
          // every pass or something like that.

          firstPass = false;
      }

      // rotate power. rotate is the desired rotation angle. power is the desired thrust power.
      // PROBLEM OUTPUT
      console.log('-90 3');

      // --- data domain ---
      const XMIN = 0, XMAX = 6999;
      const YMIN = 0, YMAX = 2999;

      // --- grid cell size (in data units) ---
      const DX = squareSize;   // width of each cell in x units
      const DY = squareSize;    // height of each cell in y units

      // --- canvas + context ---
      const c = document.getElementById('plot');
      const ctx = c.getContext('2d');

      // --- scale functions: data -> pixels ---
      const sx = x => (x - XMIN) / (XMAX - XMIN) * c.width;
      const sy = y => c.height - ((y - YMIN) / (YMAX - YMIN) * c.height); // flip Y so 0 is bottom

      // --- precompute pixel points for the polyline ---
      const pts = landOrigX.map((x, i) => ({ x: sx(x), y: sy(landOrigY[i]) }));
      const adjustPts = landX.map((x, i) => ({ x: sx(x), y: sy(landY[i]) }));

      // --- draw the polyline + points (your existing simple graph) ---
      function drawGraph() {
        // background
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, c.width, c.height);

        // line
        ctx.beginPath();
        pts.forEach((p, i) => i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y));
        ctx.strokeStyle = "#0074D9";
        ctx.lineWidth = 2;
        ctx.stroke();

        // points
        ctx.fillStyle = "#FF4136";
        pts.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawAdjustGraph() {

        // line
        ctx.beginPath();
        adjustPts.forEach((p, i) => i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y));
        ctx.strokeStyle = "#FFA500";
        ctx.lineWidth = 2;
        ctx.stroke();

        // points
        ctx.fillStyle = "#FF4136";
        adjustPts.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      // function drawAdjustGraph() {
      //   // line
      //   ctx.beginPath();
      //   // adjustPts.forEach((p, i) => i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y));
      //   for (let i = 0; i < adjustPts.length; i+=2) {
      //       ctx.moveTo(adjustPts[i].x, adjustPts[i].y)
      //       ctx.lineTo(adjustPts[i+1].x, adjustPts[i+1].y);
      //       // ctx.moveTo(adjustPts[i].x, adjustPts[i].y)
      //       // ctx.lineTo(adjustPts[i].x, adjustPts[i].y);
      //   }
      //   ctx.strokeStyle = "#FFA500";
      //   ctx.lineWidth = 2;
      //   ctx.stroke();
      //
      //   // points
      //   ctx.fillStyle = "#FF4136";
      //   adjustPts.forEach(p => {
      //     ctx.beginPath();
      //     ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
      //     ctx.fill();
      //   });
      // }

      // --- label content for each cell ---
      // Return a string to draw at the cell center.
      // You can switch what it prints by changing which return is active.
      function cellLabel(col, row, x0, y0, x1, y1, cols, rows) {
        // Option A: sequential index starting at bottom-left
        return String(row * cols + col);

        // Option B: column,row indices
        // return `${col},${row}`;

        // Option C: data-space center coordinates (rounded)
        // const xc = Math.round((x0 + x1) / 2);
        // const yc = Math.round((y0 + y1) / 2);
        // return `${xc},${yc}`;
      }

      // --- draw grid lines + labels on TOP of the graph ---
      function drawGrid() {
        const cols = Math.ceil((XMAX - XMIN) / DX);
        const rows = Math.ceil((YMAX - YMIN) / DY);

        // grid lines
        ctx.strokeStyle = "#cccccc";
        ctx.lineWidth = 1;

        // verticals
        for (let i = 0; i <= cols; i++) {
          const xData = XMIN + i * DX;
          const xPix = sx(Math.min(xData, XMAX));
          ctx.beginPath();
          ctx.moveTo(xPix, sy(YMIN));
          ctx.lineTo(xPix, sy(YMAX));
          ctx.stroke();
        }

        // horizontals
        for (let j = 0; j <= rows; j++) {
          const yData = YMIN + j * DY;
          const yPix = sy(Math.min(yData, YMAX));
          ctx.beginPath();
          ctx.moveTo(sx(XMIN), yPix);
          ctx.lineTo(sx(XMAX), yPix);
          ctx.stroke();
        }

        // labels (center of each cell)
        ctx.fillStyle = "#333333";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (let col = 0; col < cols; col++) {
          for (let row = 0; row < rows; row++) {
            const x0 = XMIN + col * DX;
            const x1 = Math.min(x0 + DX, XMAX);
            const y0 = YMIN + row * DY;
            const y1 = Math.min(y0 + DY, YMAX);

            const xc = (x0 + x1) / 2;
            const yc = (y0 + y1) / 2;

            const xp = sx(xc);
            const yp = sy(yc);

            const text = cellLabel(col, row, x0, y0, x1, y1, cols, rows);
            ctx.fillText(String(grid[row][col].toFixed(0)), xp, yp);
          }
        }
      }

      // --- render ---
      drawGraph(); // draw your plot first
      drawAdjustGraph();
      drawGrid();  // then draw the grid + labels over top

      ctx.beginPath();
      ctx.arc(sx(x), sy(y), 6, 0, Math.PI * 2);
      ctx.fillStyle = "green";
      ctx.fill();

      // point label
      ctx.fillStyle = "black";
      ctx.font = "12px sans-serif";
      ctx.fillText("Ship", sx(x) + 10, sy(y) - 10);
    </script>
  </body>
</html>
