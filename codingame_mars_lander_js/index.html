<!doctype html>
<html>
  <body>
    <!-- fixed-size canvas so we don't worry about resizing -->
    <canvas id="plot" width="3000" height="1500" style="border:1px solid #ccc"></canvas>
    <button id="playPauseBtn">Play</button>
    <input id="frameSlider" type="range" min="0" value="0" style = "width: 400px;">
    <span id="frameLabel"></span>

    <script>
      //:LiveServerStart

      const surfaceN = 7;
      const landOrigX = [0, 1000, 1500, 3000, 4000, 5500, 6999];
      const landOrigY = [100, 500, 1500, 1000, 150, 150, 800];

      console.error(landOrigX);
      console.error(landOrigY);

      // at least 1000m wide
      let firstFlatIdx = 0;
      let secondFlatIdx = 0;
      for (let i = 1; i < surfaceN; i++) {
          if (landOrigY[i] === landOrigY[i - 1]) {
              firstFlatIdx = i - 1;
              secondFlatIdx = i;
              break;
          }
      };

      // Look ahead and leeway are related, don't want the lander trying to fly
      // through a wall because it is looking too far ahead. However, the lander
      // needs to slow down fast enough too.
      const squareSize = 500;
      const leewayDist = 200;
      const vref = 40;
      const lookAheadDist = 200;

      const numberFrames = 100;
      let curFrameIndex = 0;
      const frames = [];

      const landX = [];
      const landY = [];

      // These are a segment of the y-axis, they are used to prime the formula below.
      let x1 = 0;
      let x2 = 0;
      let y1 = 0;
      let y2 = 2999;

      function intersect(x3, x4, y3, y4) {
          // intersection formula
          const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
          const newX = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4))/d;
          const newY = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4))/d;

          return [newX, newY];
      }

      const distance = (x1, y1, x2, y2) => Math.hypot((x1 - x2), (y1 - y2));

      for (let i = 1; i < surfaceN; i++) {

          let x3 = -1;
          let x4 = -1;
          let y3 = -1;
          let y4 = -1;

          if (i === secondFlatIdx) {
              x3 = landOrigX[i - 1];
              x4 = landOrigX[i];
              y3 = landOrigY[i - 1];
              y4 = landOrigY[i];
          } else {
              const dY = landOrigY[i] - landOrigY[i-1];
              const dX = landOrigX[i] - landOrigX[i-1];

              const len = Math.hypot(dX, dY);

              if (!len) continue;

              // n = (-Δy, Δx)/sqrt((Δx)^2 + (Δy)^2)
              // A' = A + h*n
              // B' = B + h*n
              const normX = leewayDist * (-dY / len);
              const normY = leewayDist * (dX / len);
              
              x3 = landOrigX[i-1] + normX;
              x4 = landOrigX[i] + normX;
              y3 = landOrigY[i-1] + normY;
              y4 = landOrigY[i] + normY;
          }

          const [newX, newY] = intersect(x3, x4, y3, y4);

          landX.push(newX);
          landY.push(newY);

          x1 = x3;
          x2 = x4;
          y1 = y3;
          y2 = y4;
      };

      const [newX, newY] = intersect(6999, 6999, 0, 2999);

      landX.push(newX);
      landY.push(newY);

      let firstPass = true;

      function gridToStandardX(coord) {
          let conversion = coord * squareSize;
          if(conversion > 6999) {
              conversion = 6999;
          }
          return conversion;
      }

      function gridToStandardY(coord) {
          let conversion = coord * squareSize;
          if(conversion > 2999) {
              conversion = 2999;
          }
          return conversion;
      }

      function standardToGrid(coord) {
          return coord/squareSize;
      }

      function standardToGridCeil(coord) {
          return Math.ceil(coord/squareSize);
      }

      function standardToGridFloor(coord) {
          return Math.floor(coord/squareSize);
      }

      function segmentsIntersect(A, B, C, D, eps = 1e-10) {
          const cross = (p, q, r) => 
              (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);

          const orient = (p, q, r) => {
              const val = cross(p, q, r);
              if (Math.abs(val) < eps) return 0; // collinear
              return val > 0 ? 1 : -1;
          }

          const o1 = orient(A, B, C);
          const o2 = orient(A, B, D);
          const o3 = orient(C, D, A);
          const o4 = orient(C, D, B);

          // General case: proper intersection
          if (o1 !== o2 && o3 !== o4) return true;

          // Collinear special cases
          const onSeg = (p, q, r) =>
              Math.min(p.x, r.x) - eps <= q.x && q.x <= Math.max(p.x, r.x) + eps &&
              Math.min(p.y, r.y) - eps <= q.y && q.y <= Math.max(p.y, r.y) + eps;

          if (o1 === 0 && onSeg(A, C, B)) return true;
          if (o2 === 0 && onSeg(A, D, B)) return true;
          if (o3 === 0 && onSeg(C, A, D)) return true;
          if (o4 === 0 && onSeg(C, B, D)) return true;

          return false;
      }

      function removeStraightPoints(path, eps = 1e-9) {
          if (!path || path.length <=2) return path ? path.slice() : [];

          const newPath = [path[0]];
          let a = path[0];
          let b = path[1];
          
          for (let i = 2; i < path.length; i++) {
              const c = path[i];
              
              const abx = b[0] - a[0];
              const aby = b[1] - a[1];
              const acx = c[0] - a[0];
              const acy = c[1] - a[1];
              
              // 2D cross product z-component: ab x ac
              const cross = abx * acy - aby * acx;
              
              if (Math.abs(cross) > eps) {
                  // direction changed
                  newPath.push(b);
                  a = b;
                  b = c;
              } else {
                  // still collinear
                  b = c;
              }
          }
          
          newPath.push(path[path.length-1]);
          return newPath;
      }

      function distancePointToLineSeg(l1, l2, p) {
          const dx = l2.x - l1.x;
          const dy = l2.y - l1.y;
          const len2 = dx*dx + dy*dy;
          if (len2 === 0) return distance(p.x, p.y, l1.x, l1.y);
          const t = ((p.x - l1.x) * dx + (p.y - l1.y) * dy) / len2
          if (t <= 0) {
              // l1 is closest point
              return {t: 0, x: l1.x, y: l1.y, dist: distance(p.x, p.y, l1.x, l1.y)};
          } else if (t >= 1) {
              // l2 is closest point
              return {t: 1, x: l2.x, y: l2.y, dist: distance(p.x, p.y, l2.x, l2.y)};
          } else {
              // On line segment
              const projX = l1.x + t * dx;
              const projY = l1.y + t * dy;
              return {t: t, x: projX, y: projY, dist: distance(p.x, p.y, projX, projY)};
          }
      }

      let x = 2500;
      let y = 2700;
      let hSpeed = 0;
      let vSpeed = 0;
      let fuel = 550;
      let rotate = 0;
      let power = 0;

      // Write an action using console.log()
      // To debug: console.error('Debug messages...');

      // Probably get above the landing area as fast as possible? This could be false later and I would
      // like to make it extendable. So maybe I need to actually find the shortest path to the surface, then
      // try to follow it closely. Although I would need to simulate that while the moves are all predictable
      // it can't follow tight paths. Maybe instead of thinking of it like a programming problem, think of it
      // like a real problem. That means I want it to work first and foremost, then I want to prio fuel, then
      // I want to prio computational efficieny.

      // Maybe break it up into a grid and do flow control over it? Then go over the path and see if it is valid & adjust
      // accordingly. OR I could figure out how tight the lander can corner and use flow control to somehow make the 
      // correct path the first time by being farther away from the edges.

      console.error(`lander [${x}, ${y}]`);
      const grid = [];
      let path = [];

      while(curFrameIndex < numberFrames) {
          console.error(`Pass ${curFrameIndex + 1}`);

          frames.push({x: x, y: y, lookAheadPoint: {x: -1, y: -1}});
          console.error(frames[curFrameIndex]);

          if (firstPass) {
              const numRows = 3000/squareSize + 1;
              const numCols = 7000/squareSize + 1; 

              const isInGridBounds = (y, x) => y >= 0 && y < numRows && x >= 0 && x < numCols;

              // How does this work?
              // Start at the current coords. Every direction works, but I want the shortest path. So 
              // some kind of backtracking algo I suppose? Maybe start at the points on the grid that 
              // are "solutions" and then use backwards induction to find the shortest path.

              // Multiple possible end points. Pick one and start there.

              // Check each direction and keep track of length. Find shortest direction once I find
              // the lander.

              // Need coords of the current lander and the coords of the end points. Maybe I will need
              // to do some extra at the start and end to go to a corner. So from startX and startY to
              // the nearest coord and such. Oh, I can just add the distance to the nearest coordinates.

              // The actual coordinate that represents each square is the bottom left.
              // This allows it to be floor(X) and floor(Y) which makes computation 
              // simpler.
              for(let i = 0; i < numRows; i++) {
                  let row = [];
                  for (let j = 0; j < numCols; j++) {
                    row.push({stop: false, dist: -1});
                  }
                  grid.push(row);
              }

              // Mark coords directly above the ground coords.
              const gridLandingPoints = [];

              const flatY = landY[firstFlatIdx];
              const gridFlatY = standardToGridCeil(flatY);
              const convertFlatY = gridToStandardY(gridFlatY);

              const distanceToSquare = distance(0, flatY, 0, convertFlatY);

              const firstFlatX = landX[firstFlatIdx];
              const firstGridFlatX = standardToGridCeil(firstFlatX);

              const secondFlatX = landX[secondFlatIdx];
              const secondGridFlatX = standardToGridFloor(secondFlatX);
              const convertSecondGridFlatX = gridToStandardX(secondGridFlatX);
              
              for(let gridFlatX = firstGridFlatX; gridFlatX <= secondGridFlatX; gridFlatX++) {
                grid[gridFlatY][gridFlatX].dist = distanceToSquare;
                grid[gridFlatY][gridFlatX].stop = true;
                gridLandingPoints.push([gridFlatY, gridFlatX]);
              }

              const orthogDistance = distance(0, 0, squareSize, 0);
              const diagonalDistance = distance(0, 0, squareSize, squareSize);
              const DIRS = [
                  [-1, -1, diagonalDistance],
                  [-1, 0, orthogDistance],
                  [-1, 1, diagonalDistance],
                  [0, -1, orthogDistance],
                  [0, 1, orthogDistance],
                  [1, -1, diagonalDistance],
                  [1, 0, orthogDistance],
                  [1, -1, diagonalDistance]
              ];

              // Calculate and save the shortest distance from each grid point to the end point. It will
              // not calculate any point that fall outside the grid and will not move through any land.

              let headIdx = 0;
              const nextPoints = [...gridLandingPoints];
              while (headIdx < nextPoints.length) {
                  const [gridY, gridX] = nextPoints[headIdx];
                  const gridDist = grid[gridY][gridX].dist;
                  let workingY = gridToStandardY(gridY);
                  const workingX = gridToStandardX(gridX);

                  // This handles an exceptional case where the grid line falls on the landing pad.
                  // If that happens, the grid will always "intercept" with the landing pad and so
                  // no distance will be generated.
                  if(distanceToSquare === 0 && gridDist === 0) {
                      // Note that this must be +1 and not -1 because the landing pad could be on
                      // the bottom of the screen (y === 0).
                      workingY += 1;
                  }
                  for (const [dy, dx, dist] of DIRS) {
                      const newGridY = gridY + dy;
                      const newGridX = gridX + dx;

                      if (isInGridBounds(newGridY, newGridX)) {
                          const newY = gridToStandardY(newGridY);
                          const newX = gridToStandardX(newGridX);

                          // So what is happening here is that when I am zero distance from the line,
                          // I intersect the ground itself when I try to go anywhere. I could try to
                          // make an exception. However, this causes problems of its own in that when
                          // do I exclude the intersection and when do I NOT exclude it?
                          let outOfBounds = false;
                          for (let i = 1; i < surfaceN; i++) {
                              if (segmentsIntersect(
                                      {x: workingX, y: workingY},
                                      {x: newX, y: newY},
                                      {x: landX[i-1], y: landY[i-1]},
                                      {x: landX[i], y: landY[i]}
                              )) {
                                  outOfBounds = true;
                                  break;
                              }
                          }

                          const calculatedNextDist = gridDist + dist;
                          const actualNextDist = grid[newGridY][newGridX].dist; 
                          if (!outOfBounds && (actualNextDist === -1 || calculatedNextDist < actualNextDist)) {
                              grid[newGridY][newGridX].dist = calculatedNextDist;
                              nextPoints.push([newGridY, newGridX]);
                          }
                      }
                  }
                  headIdx++;
              }

              const gridStartingPoints = [];

              // These points can be duplicates, so doing it this way to avoid
              // the same point being used multiple times.
              const gridLanderXCoords = new Set();
              const gridLanderYCoords = new Set();
              gridLanderXCoords.add(standardToGridFloor(x));
              gridLanderXCoords.add(standardToGridCeil(x));
              gridLanderYCoords.add(standardToGridFloor(y));
              gridLanderYCoords.add(standardToGridCeil(y));

              for (const gridX of gridLanderXCoords) {
                  for (const gridY of gridLanderYCoords) {
                      // Convert grid coords back to actual coords.
                      const landerX = gridToStandardX(gridX);
                      const landerY = gridToStandardY(gridY);

                      gridStartingPoints.push([gridY, gridX]);

                      // If this point could not be reached by the above algo, there is no
                      // path to reach the landing pad.
                      if (grid[gridY][gridX].dist !== -1) {
                          grid[gridY][gridX].dist += distance(x, y, landerX, landerY);
                      }
                  }
              }

              let smallest = -1;
              let pathX = -1;
              let pathY = -1;

              //find the shorest path around the lander
              for (const [startX, startY] of gridStartingPoints) {
                  if (smallest === -1 || grid[startY][startX].dist < smallest) {
                      pathX = startX;
                      pathY = startY;
                      smallest = grid[startY][startX].dist;
                  }
              }
              
              // Add the lander location to the path.
              path.push([x, y]);

              // Add the first location to the path.
              path.push([pathX, pathY]);

              let iter = 0;
              const MAX_ITERS = 1e6; // fail-safe

              while(true) {
                  const [curX, curY] = path[path.length-1];
                  smallest = -1;
                  for (const [dy, dx, _] of DIRS) {
                      const newX = curX + dx;
                      const newY = curY + dy;

                      if (isInGridBounds(newY, newX) && grid[newY][newX].dist !== -1
                          && (smallest === -1 || grid[newY][newX].dist < smallest)
                      ) {
                          pathX = newX;
                          pathY = newY;
                          smallest = grid[newY][newX].dist;
                      }
                  }
                  path.push([pathX, pathY]);

                  if(grid[pathY][pathX].stop) {
                        break;
                  }

                  if (++iter > MAX_ITERS) throw new Error(`Path search exceeded MAX_ITERS [${pathX}, ${pathY}]`);
                }

              // Convert path coords from grid coords. Idx 0 is already converted.
              for (let i = 1; i < path.length; i++) {
                 path[i][0] = gridToStandardX(path[i][0]);
                 path[i][1] = gridToStandardY(path[i][1]);
              }

              // Get the last point that is at the safe spot to land.
              path.push([path[path.length - 1][0], landY[firstFlatIdx]]);

              path = removeStraightPoints(path);

              // TODO: Need to smooth the line (cubic Hermite spline?)
              // TODO: Maybe do corners based on turn radius of lander.

              firstPass = false;
          }

          // Find the shortest distance to the path.
          let shortestPathPoint = {
              segIdx: 0,
              t: 0,
              x: path[0][0],
              y: path[0][1],
              dist: Infinity
          };
          for (let i = 1; i < path.length; i++) {
            const pointOne = {x: path[i - 1][0], y: path[i - 1][1]};
            const pointTwo = {x: path[i][0], y: path[i][1]};

            const out = distancePointToLineSeg(pointOne, pointTwo, {x: x, y: y});
            if (out.dist < shortestPathPoint.dist) {
              shortestPathPoint = {segIdx: i - 1, t: out.t, x: out.x, y: out.y, dist: out.dist };
              console.error(shortestPathPoint);
            }
          }

          // Find the look ahead point on the path.
          let curPathIdx = shortestPathPoint.segIdx;
          let distRemaining = lookAheadDist;
          let nearEnd = false;
          const lookAheadPoint = {x: 0, y: 0};
          const unitTangent = {x: 0, y: 0};
          while(true) {
              const [x0, y0] = path[curPathIdx];
              const [x1, y1] = path[curPathIdx + 1];
              const dx = x1 - x0;
              const dy = y1 - y0;
              const segDist = Math.hypot(dx, dy);

              if (segDist === 0) {
                  if (curPathIdx === path.length - 1) {
                      lookAheadPoint.x = x1;
                      lookAheadPoint.y = y1;
                      unitTangent.x = dx / segDist;
                      unitTangent.y = dy / segDist;
                      nearEnd = true;
                      break;
                  }
                  curPathIdx++;
                  continue;
              }

              if (distRemaining > segDist) {
                  if (curPathIdx === path.length - 1) {
                      lookAheadPoint.x = x1;
                      lookAheadPoint.y = y1;
                      unitTangent.x = dx / segDist;
                      unitTangent.y = dy / segDist;
                      nearEnd = true;
                      break;
                  }
                  distRemaining -= segDist;
                  curPathIdx++;
                  continue;
              }

              const tStart = (curPathIdx === shortestPathPoint.segIdx) ? shortestPathPoint.t : 0;
              const distOnSeg = segDist * (1 - tStart);

              if (distRemaining <= distOnSeg || curPathIdx === path.length - 2) {
                  const t = distRemaining / segDist;
                  unitTangent.x = dx / segDist;
                  unitTangent.y = dy / segDist;
                  lookAheadPoint.x = x0 + t * (x1 - x0);
                  lookAheadPoint.y = y0 + t * (y1 - y0);
                  break;
              }

              distRemaining -= distOnSeg;
              curPathIdx++;
          }

          frames[curFrameIndex].lookAheadPoint.x = lookAheadPoint.x;
          frames[curFrameIndex].lookAheadPoint.y = lookAheadPoint.y;

          console.error(path);
          console.error(lookAheadPoint);

          // (p, v) -> (pref, vref)
          // ep = pref - p
          // ev = vref - v
          // acmd = Kp * ep + Kd * ev

          // TODO: Can use a modest look ahead proportional to speed 
          // so at higher speeds I look further ahead and don’t snake.
          // Might also want to bring the velocity lower as I get close
          // to the ground.
          // Desired velocity at look ahead point (m/s).

          const vrefX = vref * unitTangent.x;
          const vrefY = vref * unitTangent.y;

          // How fast I want errors to die out.
          const naturalFrequency = 0.2; 
          // How "snappy" vs "overshooty".
          const dampingRatio = 0.8;

          const proportionalGain = naturalFrequency * naturalFrequency;
          const derivativeGain = 2 * naturalFrequency * dampingRatio;

          const posErrX = lookAheadPoint.x - x;
          const posErrY = lookAheadPoint.y - y;
          const velErrX = vrefX - hSpeed;
          const velErrY = vrefY - vSpeed;

          const accCmdX = proportionalGain * posErrX + derivativeGain * velErrX;
          const accCmdY = proportionalGain * posErrY + derivativeGain * velErrY;

          // F = aCmd - g
          // g = -3.711 m/s^2
          let forceX = accCmdX;
          let forceY = accCmdY + 3.711;

          // In m/s.
          let magnitude = Math.hypot(forceY, forceX);
          // In radians.
          let direction = Math.atan2(forceY, forceX);

          const maxThrust = 4;
          const maxRotation = 90;
          const minRotation = -90;

          if (magnitude > maxThrust) {
              const scale = maxThrust / magnitude;
              forceX *= scale;
              forceY *= scale;
              magnitude = maxThrust;
              direction = Math.atan2(forceY, forceX);
          }

          magnitude = Math.round(magnitude);

          // Can only go +/- 1 per tick
          magnitude = Math.min(power + 1, Math.max(power - 1, magnitude));

          // Convert direction to degrees and y axis rotation.
          direction = (direction * (180/Math.PI)) - 90;

          // Clamp direction between max and min values.
          direction = Math.min(maxRotation, Math.max(direction, minRotation));

          direction = Math.round(direction);

          // Can only go +/- 15 degrees per tick.
          direction = Math.min(rotate + 15, Math.max(direction, rotate - 15));

          // Rotation goes from 90->-90 in increments of 15. Counterclockwise is
          // positive. Clockwise is negative.
          // Thrust goes from 0->4 in incremements of 1.
          // For the first move, I need to go right and down. So I need to rotate
          // -90 degrees or something for the x and not at all for the y.
          console.error(magnitude, direction);

          // PROBLEM OUTPUT
          console.log(direction, magnitude);
          
          rotate = direction;
          power = magnitude;

          const prevX = x;
          const prevY = y;
          const prevHSpeed = hSpeed;
          const prevVSpeed = vSpeed;

          fuel -= Math.max(magnitude - 1, 0);

          const dirRad = direction * Math.PI / 180;

          // direction at 0 degrees is pointing straight up so cos and sin
          // end up swapped.
          const finalThrust = {
              x: magnitude * -Math.sin(dirRad),
              y: magnitude * Math.cos(dirRad)
          };

          // Standard physics coords (y-axis points upward), mars gravity.
          const finalAcc = {
              x: finalThrust.x,
              y: finalThrust.y - 3.711
          }; 

          // t = 1 second
          hSpeed = prevHSpeed + finalAcc.x;
          vSpeed = prevVSpeed + finalAcc.y;
          x = prevX + prevHSpeed + 0.5 * finalAcc.x;
          y = prevY + prevVSpeed + 0.5 * finalAcc.y;
          console.error(x, y);

          curFrameIndex++;
      }

      // --- data domain ---
      const XMIN = 0, XMAX = 6999;
      const YMIN = 0, YMAX = 2999;

      // --- grid cell size (in data units) ---
      const DX = squareSize;   // width of each cell in x units
      const DY = squareSize;    // height of each cell in y units

      // --- canvas + context ---
      const c = document.getElementById('plot');
      const ctx = c.getContext('2d');

      // --- scale functions: data -> pixels ---
      const sx = x => (x - XMIN) / (XMAX - XMIN) * c.width;
      const sy = y => c.height - ((y - YMIN) / (YMAX - YMIN) * c.height); // flip Y so 0 is bottom
      
      // --- precompute pixel points for the polyline ---
      let pts = landOrigX.map((x, i) => ({ x: sx(x), y: sy(landOrigY[i]) }));
      let adjustPts = landX.map((x, i) => ({ x: sx(x), y: sy(landY[i]) }));
      let pathPts = path.map((pt) => ({ x: sx(pt[0]), y: sy(pt[1]) }));

      // --- draw the polyline + points (your existing simple graph) ---
      function drawGraph() {
        // background
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, c.width, c.height);

        // line
        ctx.beginPath();
        pts.forEach((p, i) => i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y));
        ctx.strokeStyle = "#0074D9";
        ctx.lineWidth = 2;
        ctx.stroke();

        // points
        ctx.fillStyle = "#FF4136";
        pts.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawAdjustGraph() {

        // line
        ctx.beginPath();
        adjustPts.forEach((p, i) => i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y));
        ctx.strokeStyle = "#FFA500";
        ctx.lineWidth = 2;
        ctx.stroke();

        // points
        ctx.fillStyle = "#FF4136";
        adjustPts.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawPath() {

        // line
        ctx.beginPath();
        pathPts.forEach((p, i) => i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y));
        ctx.strokeStyle = "#964b00";
        ctx.lineWidth = 2;
        ctx.stroke();

        // points
        ctx.fillStyle = "#FF4136";
        pathPts.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      // --- label content for each cell ---
      // Return a string to draw at the cell center.
      // You can switch what it prints by changing which return is active.
      function cellLabel(col, row, x0, y0, x1, y1, cols, rows) {
        // Option A: sequential index starting at bottom-left
        return String(row * cols + col);

        // Option B: column,row indices
        // return `${col},${row}`;

        // Option C: data-space center coordinates (rounded)
        // const xc = Math.round((x0 + x1) / 2);
        // const yc = Math.round((y0 + y1) / 2);
        // return `${xc},${yc}`;
      }

      // --- draw grid lines + labels on TOP of the graph ---
      function drawGrid() {
        const cols = Math.ceil((XMAX - XMIN) / DX);
        const rows = Math.ceil((YMAX - YMIN) / DY);

        // grid lines
        ctx.strokeStyle = "#cccccc";
        ctx.lineWidth = 1;

        // verticals
        for (let i = 0; i <= cols; i++) {
          const xData = XMIN + i * DX;
          const xPix = sx(Math.min(xData, XMAX));
          ctx.beginPath();
          ctx.moveTo(xPix, sy(YMIN));
          ctx.lineTo(xPix, sy(YMAX));
          ctx.stroke();
        }

        // horizontals
        for (let j = 0; j <= rows; j++) {
          const yData = YMIN + j * DY;
          const yPix = sy(Math.min(yData, YMAX));
          ctx.beginPath();
          ctx.moveTo(sx(XMIN), yPix);
          ctx.lineTo(sx(XMAX), yPix);
          ctx.stroke();
        }

        // labels (center of each cell)
        ctx.fillStyle = "#333333";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (let col = 0; col < cols; col++) {
          for (let row = 0; row < rows; row++) {
            const x0 = XMIN + col * DX;
            const x1 = Math.min(x0 + DX, XMAX);
            const y0 = YMIN + row * DY;
            const y1 = Math.min(y0 + DY, YMAX);

            const xc = (x0 + x1) / 2;
            const yc = (y0 + y1) / 2;

            const xp = sx(xc);
            const yp = sy(yc);

            const text = cellLabel(col, row, x0, y0, x1, y1, cols, rows);
            ctx.fillText(String(grid[row][col].dist.toFixed(0)), xp, yp);
          }
        }
      }

      function drawShipAndLookAhead(x, y, lookAheadPoint) {
          // lander point
          ctx.beginPath();
          ctx.arc(sx(x), sy(y), 6, 0, Math.PI * 2);
          ctx.fillStyle = "green";
          ctx.fill();

          // lander point label
          ctx.fillStyle = "black";
          ctx.font = "12px sans-serif";
          ctx.fillText("Ship", sx(x) + 10, sy(y) - 10);

          // look ahead point 
          ctx.beginPath();
          ctx.arc(sx(lookAheadPoint.x), sy(lookAheadPoint.y), 6, 0, Math.PI * 2);
          ctx.fillStyle = "red";
          ctx.fill();

          // look ahead point label
          ctx.fillStyle = "black";
          ctx.font = "12px sans-serif";
          ctx.fillText("Look Ahead", sx(lookAheadPoint.x) + 10, sy(lookAheadPoint.y) - 10);
      }

      function drawFrame(frameIndex) {
          const frame = frames[frameIndex];
          if (!frame) return;
 
          // clear / background
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, c.width, c.height);

          // --- render ---
          drawGraph(); // draw your plot first
          drawAdjustGraph();
          drawPath();
          drawGrid();  // then draw the grid + labels over top

          // current ship + look-ahead
          drawShipAndLookAhead(frame.x, frame.y, frame.lookAheadPoint);
      }

      const playPauseBtn = document.getElementById('playPauseBtn');
      const frameSlider = document.getElementById('frameSlider');
      const frameLabel = document.getElementById('frameLabel');

      // TODO: This is the number of iterations it will go through.
      frameSlider.max = numberFrames - 1;      

      let currentFrame = 0;
      let playing = false;
      let timerId = null;
      const FRAME_MS = 100; // 100 ms between frame = 10 fps

      function goToFrame(index) {
        currentFrame = Math.max(0, Math.min(index, numberFrames));
        frameSlider.valud = currentFrame;
        frameLabel.textContent = `Frame: ${currentFrame}`;
        drawFrame(currentFrame);
      }

      function startPlayback() {
        if (playing) return;
        playing = true;
        playPauseBtn.textContent = "Pause";

        timerId = setInterval(() => {
          if (currentFrame >= frames.length - 1) {
            // stop at the end (or loop: currentFrame = 0)
            stopPlayback();
            return;
          }
          goToFrame(currentFrame + 1);
        }, FRAME_MS);
      }

      function stopPlayback() {
        playing = false;
        playPauseBtn.textContent = "Play";
        if (timerId !== null) {
          clearInterval(timerId);
          timerId = null;
        }
      }

      // Button: toggle play/pause
      playPauseBtn.addEventListener('click', () => {
        if (playing) {
          stopPlayback();
        } else {
          startPlayback();
        }
      });

      // Slider: scrub to a specific frame (feeze / jump)
      frameSlider.addEventListener('input', (e) => {
        const idx = Number(e.target.value);
        stopPlayback(); // scrubbing implicitly "freezes"
        goToFrame(idx);
      });

      goToFrame(0);

    </script>
  </body>
</html>
